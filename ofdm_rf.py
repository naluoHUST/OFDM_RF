# -*- coding: utf-8 -*-
"""OFDM_test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O-zqfEqsuBqw6miKiVQgJG4gnBUmQXME
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erf,erfc
import scipy
#number of subcarrier
K = 64
#cyclic prefix
CP = K//4
#pilot
P = 8
M = 4 #bits per symbol (16QAM)
Channel_response = np.array([0.5, 0.5, 0.5 - 0.3j])
H_exact = np.fft.fft(Channel_response, K)

SNRdB = 25
pilotValue = 3 + 3j
allCarriers = np.arange(K)
pilotCarriers = allCarriers[::K//P]

pilotCarriers = np.hstack([pilotCarriers, np.array([allCarriers[-1]])])

P = P+1

# Carrier mang thông tin
dataCarriers = np.delete(allCarriers, pilotCarriers)

totalbit_OFDM = len(dataCarriers)*M

bit_sequence = np.random.binomial(n=1, p=0.5, size=(totalbit_OFDM, ))
# print(bit_sequence)

mapping = {
    (0,0,0,0) : -3-3j,
    (0,0,0,1) : -3-1j,
    (0,0,1,0) : -3+3j,
    (0,0,1,1) : -3+1j,
    (0,1,0,0) : -1-3j,
    (0,1,0,1) : -1-1j,
    (0,1,1,0) : -1+3j,
    (0,1,1,1) : -1+1j,
    (1,0,0,0) :  3-3j,
    (1,0,0,1) :  3-1j,
    (1,0,1,0) :  3+3j,
    (1,0,1,1) :  3+1j,
    (1,1,0,0) :  1-3j,
    (1,1,0,1) :  1-1j,
    (1,1,1,0) :  1+3j,
    (1,1,1,1) :  1+1j
}

#mapping 16QAM
for b3 in [0, 1]:
    for b2 in [0, 1]:
        for b1 in [0, 1]:
            for b0 in [0, 1]:
                B = (b3, b2, b1, b0)
                Q = mapping[B]
                # plt.plot(Q.real, Q.imag, 'bo')
                # plt.text(Q.real, Q.imag+0.2, "".join(str(x) for x in B), ha='center')
demapping_table = {v : k for k, v in mapping.items()}
# allCarriers
# [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
#  24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
#  48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63]

# pilotCarriers
# [ 0  8 16 24 32 40 48 56 63]

# dataCarriers
# [ 1  2  3  4  5  6  7  9 10 11 12 13 14 15 17 18 19 20 21 22 23 25 26 27
#  28 29 30 31 33 34 35 36 37 38 39 41 42 43 44 45 46 47 49 50 51 52 53 54
#  55 57 58 59 60 61 62]

# plt.plot(pilotCarriers, np.zeros_like(pilotCarriers), 'go', label='pilot')
# plt.plot(dataCarriers, np.zeros_like(dataCarriers), 'ro', label='data')



# plt.plot(allCarriers, abs(H_exact))

# print(bit_sequence[:50])

#serial to paralell
def S_P(bits):
  return bits.reshape(len(dataCarriers), M)
bits_SP = S_P(bit_sequence)
# print(bits_SP)
# print(len(bits_SP))
def Mapping(bits):
    return np.array([mapping[tuple(b)] for b in bits])
QAM = Mapping(bits_SP)
# print (bits_SP[:5,:])
# print (QAM[:5])
# [[1 0 1 1]
#  [1 1 1 1]
#  [1 0 0 0]
#  [1 0 0 0]
#  [1 1 1 0]]
# [3.+1.j 1.+1.j 3.-3.j 3.-3.j 1.+3.j]
def OFDM_symbol(QAM_payload):
    symbol = np.zeros(K, dtype=complex)
    symbol[pilotCarriers] = pilotValue
    symbol[dataCarriers] = QAM_payload
    return symbol
OFDM_data = OFDM_symbol(QAM)
#print(OFDM_data)
def IDFT(OFDM_data):
    return np.fft.ifft(OFDM_data)
OFDM_time = IDFT(OFDM_data)

# Number of OFDM samples in time-domain before CP:  64
def addCP(OFDM_time):
    cp = OFDM_time[-CP:]
    return np.hstack([cp, OFDM_time])
OFDM_withCP = addCP(OFDM_time)
#print(OFDM_withCP)


def channel(signal):
    Y = np.convolve(signal, Channel_response)
    signal_power = np.mean(abs(Y**2))

    noise_power = signal_power * 10**(-SNRdB/10)
    noise = np.sqrt(noise_power/2) * (np.random.randn(*Y.shape)+1j*np.random.randn(*Y.shape))
    return Y + noise
OFDM_TX = OFDM_withCP
OFDM_RX = channel(OFDM_TX)
# plt.figure(figsize=(8,2))
# plt.plot(abs(OFDM_TX), label='TX')
# plt.plot(abs(OFDM_RX), label='RX')
# plt.legend(fontsize=10)
# plt.xlabel('Time')
# plt.ylabel('x(t)')
# plt.grid(True)
#loại bỏ cyclic prefix
def removeCP(signal):
    return signal[CP:(CP+K)]
OFDM_RX_noCP = removeCP(OFDM_RX)
#đưa về miền tần số
def DFT(OFDM_RX):
    return np.fft.fft(OFDM_RX)
OFDM_demod = DFT(OFDM_RX_noCP)
#print(OFDM_demod)

def channelEstimate(OFDM_demod):
    pilots = OFDM_demod[pilotCarriers]
    H_est_at_pilots = pilots / pilotValue # Channel gain ước lượng ở sóng mang chứa pilot

    # Nội suy ra H_estimate từ H_est_pilot

    H_est_abs = scipy.interpolate.interp1d(pilotCarriers, abs(H_est_at_pilots), kind='linear')(allCarriers)
    H_est_phase = scipy.interpolate.interp1d(pilotCarriers, np.angle(H_est_at_pilots), kind='linear')(allCarriers)
    H_est = H_est_abs * np.exp(1j*H_est_phase)

    plt.plot(allCarriers, abs(H_exact), label='Correct')
    plt.stem(pilotCarriers, abs(H_est_at_pilots), label='Pilot')
    plt.plot(allCarriers, abs(H_est), label='Estimated')
    plt.grid(True)
    plt.xlabel('Carrier index'); plt.ylabel('|H(f)|')
    plt.legend(fontsize=10)
    plt.ylim(0,2)

    return H_est
H_est = channelEstimate(OFDM_demod)

#Bù
def equalize(OFDM_demod, H_est):
    return OFDM_demod / H_est
equalized_H_est = equalize(OFDM_demod, H_est)

def get_payload(equalized):
    return equalized[dataCarriers]
QAM_est = get_payload(equalized_H_est)
# plt.plot(QAM_est.real, QAM_est.imag, 'bo')

def demapping(QAM):
  constel = np.array([x for x in demapping_table.keys()])

  #khoang cach tu diem nhan duoc den diem constel gan nhat co the
  dis = abs(QAM.reshape((-1, 1)) - constel.reshape((1, -1)))
  constel_index = dis.argmin(axis = 1)
  HDecision = constel[constel_index]
  return np.vstack([demapping_table[C] for C in HDecision]), HDecision

PS_est, HDecision = demapping(QAM_est)
# for qam, hard in zip(QAM_est, HDecision):
#     plt.plot([qam.real, hard.real], [qam.imag, hard.imag], 'b-o');
#     plt.plot(HDecision.real, HDecision.imag, 'ro')

def PS(bits):
    return bits.reshape((-1,))
bits_est = PS(PS_est)
print(bits_est)

BER = np.mean(bit_sequence != bits_est)
print(BER)

import numpy as np
import itertools




K = 16  # Number of subcarriers
M = 2   # Modulation order
data = np.array([0, 1, 1, 0, 0, 1, 0, 1])
snr_db = 25
def S_P(bits, M):
    return bits.reshape(-1, M)

# Split data into symbols
symbol = S_P(data, M)
print(symbol)
def qam_mapping(M):
    n = int(np.log2(M))
    mapping = {}
    for i, bits in enumerate(itertools.product([0, 1], repeat=n)):
        I = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[:n // 2])]) - (2 ** (n // 2)) + 1
        Q = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[n // 2:])]) - (2 ** (n // 2)) + 1
        mapping[bits] = I + 1j * Q
    return mapping

mapping = qam_mapping(2 ** M)
print(mapping)
def Mapping(bits):
    return np.array([mapping[tuple(b)] for b in bits])

symbol_mapped = Mapping(symbol)
print(symbol_mapped)

def hermitian_aco(symbol_mapped, K):
    SYMETRICarray = np.zeros(K, dtype=complex)

    odd_index = 1
    for i in range(len(symbol_mapped)):
        if odd_index < K // 2:
            SYMETRICarray[odd_index] = symbol_mapped[i]
            SYMETRICarray[K - odd_index] = np.conjugate(symbol_mapped[i])
            odd_index += 2  # Move to the next odd index

    return SYMETRICarray

HermittianSymetry = hermitian_aco(symbol_mapped, K)
print(HermittianSymetry)

def IFFT(HermittianSymetry):
        return np.fft.ifft(HermittianSymetry)

AfterIFFT = IFFT(HermittianSymetry)
print(AfterIFFT)

def Clipping(AfterIFFT):
     clippedsignal = np.maximum(AfterIFFT, 0)
     return clippedsignal

AfterClipping = Clipping(AfterIFFT)
print(AfterClipping)

def channel(signal, snr_db):
    Channel_response = np.array([1])
    Y = np.convolve(signal, Channel_response)[:len(signal)]
    signal_power = np.mean(np.abs(Y) ** 2)
    noise_power = signal_power * 10 ** (-snr_db / 10)
    noise = np.sqrt(noise_power / 2) * np.random.randn(*Y.shape)
    return Y + noise

ACO_RX = channel(AfterClipping, snr_db)
print(ACO_RX)
def FFT(ACO_RX):
        return np.fft.fft(ACO_RX)

AfterFFT = FFT(ACO_RX)
print(AfterFFT)

def message_ext(AfterFFT):
    symbol_ext = []
    for i in range(len(AfterFFT)//2):
         if i % 2 != 0:
              symbol_ext.append(2*AfterFFT[i])
    return symbol_ext
symbol_ext = message_ext(AfterFFT)
print(symbol_ext)

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erf, erfc
import scipy

# number of subcarriers
K = 64
# cyclic prefix
CP = K // 4
# pilot
P = 8
M = 4  # bits per symbol (16QAM)
Chan_gain = np.array([1])
H_exact = np.fft.fft(Chan_gain, K)


SNRdB = np.linspace(10, 20)  # SNR range
pilotValue = 3 + 3j
allCarriers = np.arange(K)
pilotCarriers = allCarriers[::K // P]
pilotCarriers = np.hstack([pilotCarriers, np.array([allCarriers[-1]])])
P = P + 1

# Carrier mang thông tin
dataCarriers = np.delete(allCarriers, pilotCarriers)
totalbit_OFDM = len(dataCarriers) * M
# print(totalbit_OFDM)
bit_sequence = np.random.binomial(n=1, p=0.5, size=(totalbit_OFDM, ))

mapping = {
    (0, 0, 0, 0): -3-3j,
    (0, 0, 0, 1): -3-1j,
    (0, 0, 1, 0): -3+3j,
    (0, 0, 1, 1): -3+1j,
    (0, 1, 0, 0): -1-3j,
    (0, 1, 0, 1): -1-1j,
    (0, 1, 1, 0): -1+3j,
    (0, 1, 1, 1): -1+1j,
    (1, 0, 0, 0): 3-3j,
    (1, 0, 0, 1): 3-1j,
    (1, 0, 1, 0): 3+3j,
    (1, 0, 1, 1): 3+1j,
    (1, 1, 0, 0): 1-3j,
    (1, 1, 0, 1): 1-1j,
    (1, 1, 1, 0): 1+3j,
    (1, 1, 1, 1): 1+1j
}

demapping_table = {v: k for k, v in mapping.items()}

def S_P(bits):
    return bits.reshape(len(dataCarriers), M)

bits_SP = S_P(bit_sequence)


def Mapping(bits):
    return np.array([mapping[tuple(b)] for b in bits])

QAM = Mapping(bits_SP)

def OFDM_symbol(QAM_payload):
    symbol = np.zeros(K, dtype=complex)
    symbol[pilotCarriers] = pilotValue
    symbol[dataCarriers] = QAM_payload
    return symbol

OFDM_data = OFDM_symbol(QAM)

def IDFT(OFDM_data):
    return np.fft.ifft(OFDM_data)

OFDM_time = IDFT(OFDM_data)

print(OFDM_time)
def addCP(OFDM_time):
    cp = OFDM_time[-CP:]
    return np.hstack([cp, OFDM_time])

OFDM_withCP = addCP(OFDM_time)
print(OFDM_withCP)
def channel(signal, snr_db):
    Y = np.convolve(signal, Chan_gain)[:len(signal)]
    signal_power = np.mean(abs(Y**2))
    noise_power = signal_power * 10**(-snr_db / 10)
    noise = np.sqrt(noise_power) * (np.random.randn(*Y.shape) + 1j*np.random.randn(*Y.shape))
    return Y + noise

def removeCP(signal):
    return signal[CP:(CP + K)]

def DFT(OFDM_RX):
    return np.fft.fft(OFDM_RX)

def channelEstimate(OFDM_demod):
    pilots = OFDM_demod[pilotCarriers]
    H_est_at_pilots = pilots / pilotValue

    H_est_abs = scipy.interpolate.interp1d(pilotCarriers, abs(H_est_at_pilots), kind='linear')(allCarriers)
    H_est_phase = scipy.interpolate.interp1d(pilotCarriers, np.angle(H_est_at_pilots), kind='linear')(allCarriers)
    H_est = H_est_abs * np.exp(1j * H_est_phase)

    return H_est

def equalize(OFDM_demod, H_est):
    return OFDM_demod / H_est

def get_payload(equalized):
    return equalized[dataCarriers]

def demapping(QAM):
    constel = np.array([x for x in demapping_table.keys()])
    dis = abs(QAM.reshape((-1, 1)) - constel.reshape((1, -1)))
    constel_index = dis.argmin(axis=1)
    HDecision = constel[constel_index]
    return np.vstack([demapping_table[C] for C in HDecision]), HDecision

def PS(bits):
    return bits.reshape((-1,))

BER = []

for snr_db in SNRdB:
  A = np.zeros(100000)
  for i in range(1, 100000):
      OFDM_RX = channel(OFDM_withCP, snr_db)
      OFDM_RX_noCP = removeCP(OFDM_RX)
      OFDM_demod = DFT(OFDM_RX_noCP)
      H_est = channelEstimate(OFDM_demod)
      equalized_H_est = equalize(OFDM_demod, H_est)
      QAM_est = get_payload(equalized_H_est)
      PS_est, HDecision = demapping(QAM_est)
      bits_est = PS(PS_est)
      A[i] = np.mean(bit_sequence != bits_est)
  BER.append(np.mean(A))
# for qam, hard in zip(QAM_est, HDecision):
#     plt.plot([qam.real, hard.real], [qam.imag, hard.imag], 'b-o');
#     plt.plot(HDecision.real, HDecision.imag, 'ro')


# plt.figure(figsize=(8, 4))
# plt.plot(SNRdB, BER, 'bo-')
# plt.semilogy()
# plt.xlabel('SNR (dB)')
# plt.ylabel('BER')
# plt.grid(True)
# plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erf, erfc
import scipy
import itertools
# number of subcarriers
K = 64
# cyclic prefix
CP = K // 4
# pilot
P = 8
M = 6  # bits per symbol (16QAM)
Channel_response = np.array([1])
H_exact = np.fft.fft(Channel_response, K)

SNRdB = np.linspace(10, 20, num=10)  # SNR range, thêm num=10 để tạo mảng có 10 giá trị
pilotValue = 3 + 3j
allCarriers = np.arange(K)
pilotCarriers = allCarriers[::K // P]
pilotCarriers = np.hstack([pilotCarriers, np.array([allCarriers[-1]])])
P = P + 1

# Carrier mang thông tin
dataCarriers = np.delete(allCarriers, pilotCarriers)
totalbit_OFDM = len(dataCarriers) * M
print(totalbit_OFDM)
bit_sequence = np.random.binomial(n=1, p=0.5, size=(totalbit_OFDM, ))

# mapping = {
#     (0, 0, 0, 0): -3-3j,
#     (0, 0, 0, 1): -3-1j,
#     (0, 0, 1, 0): -3+3j,
#     (0, 0, 1, 1): -3+1j,
#     (0, 1, 0, 0): -1-3j,
#     (0, 1, 0, 1): -1-1j,
#     (0, 1, 1, 0): -1+3j,
#     (0, 1, 1, 1): -1+1j,
#     (1, 0, 0, 0): 3-3j,
#     (1, 0, 0, 1): 3-1j,
#     (1, 0, 1, 0): 3+3j,
#     (1, 0, 1, 1): 3+1j,
#     (1, 1, 0, 0): 1-3j,
#     (1, 1, 0, 1): 1-1j,
#     (1, 1, 1, 0): 1+3j,
#     (1, 1, 1, 1): 1+1j
# }




def qam_mapping(M):
    n = int(np.log2(M))
    mapping = {}
    for i, bits in enumerate(itertools.product([0, 1], repeat=n)):
        I = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[:n // 2])]) - (2 ** (n // 2)) + 1
        Q = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[n // 2:])]) - (2 ** (n // 2)) + 1
        mapping[bits] = I + 1j * Q
    return mapping
mapping = qam_mapping(2**M)
demapping_table = {v: k for k, v in mapping.items()}

def S_P(bits):
    return bits.reshape(len(dataCarriers), M)

bits_SP = S_P(bit_sequence)

def Mapping(bits):
    return np.array([mapping[tuple(b)] for b in bits])

QAM = Mapping(bits_SP)

def OFDM_symbol(QAM_payload):
    symbol = np.zeros(K, dtype=complex)
    symbol[pilotCarriers] = pilotValue
    symbol[dataCarriers] = QAM_payload
    return symbol

OFDM_data = OFDM_symbol(QAM)

def IDFT(OFDM_data):
    return np.fft.ifft(OFDM_data)

OFDM_time = IDFT(OFDM_data)

def addCP(OFDM_time):
    cp = OFDM_time[-CP:]
    return np.hstack([cp, OFDM_time])

OFDM_withCP = addCP(OFDM_time)
print(OFDM_withCP)

def channel(signal, snr_db):
    Y = np.convolve(signal, Channel_response)[:len(signal)]
    signal_power = np.mean(abs(Y**2))
    noise_power = signal_power * 10**(-snr_db / 10)
    noise = np.sqrt(noise_power/2) * (np.random.randn(*Y.shape) + 1j*np.random.randn(*Y.shape))
    return Y + noise

def removeCP(signal):
    return signal[CP:(CP + K)]

def DFT(OFDM_RX):
    return np.fft.fft(OFDM_RX)

def channelEstimate(OFDM_demod):
    pilots = OFDM_demod[pilotCarriers]
    H_est_at_pilots = pilots / pilotValue

    H_est_abs = scipy.interpolate.interp1d(pilotCarriers, abs(H_est_at_pilots), kind='linear')(allCarriers)
    H_est_phase = scipy.interpolate.interp1d(pilotCarriers, np.angle(H_est_at_pilots), kind='linear')(allCarriers)
    H_est = H_est_abs * np.exp(1j * H_est_phase)

    return H_est

def equalize(OFDM_demod, H_est):
    return OFDM_demod / H_est

def get_payload(equalized):
    return equalized[dataCarriers]

def demapping(QAM):
    constel = np.array([x for x in demapping_table.keys()])
    dis = abs(QAM.reshape((-1, 1)) - constel.reshape((1, -1)))
    constel_index = dis.argmin(axis=1)
    HDecision = constel[constel_index]
    return np.vstack([demapping_table[C] for C in HDecision]), HDecision

def PS(bits):
    return bits.reshape((-1,))

BER = []

for snr_db in SNRdB:
    A = np.zeros(10000)
    for i in range(10000):
        OFDM_RX = channel(OFDM_withCP, snr_db)
        OFDM_RX_noCP = removeCP(OFDM_RX)
        OFDM_demod = DFT(OFDM_RX_noCP)
        H_est = channelEstimate(OFDM_demod)
        equalized_H_est = equalize(OFDM_demod, H_est)
        QAM_est = get_payload(equalized_H_est)
        PS_est, HDecision = demapping(QAM_est)
        bits_est = PS(PS_est)
        A[i] = np.mean(bit_sequence != bits_est)
    BER.append(np.mean(A))

for qam, hard in zip(QAM_est, HDecision):
    plt.plot([qam.real, hard.real], [qam.imag, hard.imag], 'b-o')
    plt.plot(HDecision.real, HDecision.imag, 'ro')

plt.figure(figsize=(8, 4))
plt.plot(SNRdB, BER, 'bo-')
plt.semilogy()
plt.xlabel('SNR (dB)')
plt.ylabel('BER')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erf, erfc
import scipy
import itertools
# number of subcarriers
K = 1024
# cyclic prefix
CP = K // 4
# pilot
P = 128
M = 6  # bits per symbol (16QAM)
Channel_response = np.array([1])
H_exact = np.fft.fft(Channel_response, K)

SNRdB = np.linspace(10, 20, num=10)
pilotValue = 3 + 3j
allCarriers = np.arange(K)
pilotCarriers = allCarriers[::K // P]
pilotCarriers = np.hstack([pilotCarriers, np.array([allCarriers[-1]])])
P = P + 1

# Carrier mang thông tin
dataCarriers = np.delete(allCarriers, pilotCarriers)
totalbit_OFDM = len(dataCarriers) * M
print(totalbit_OFDM)
bit_sequence = np.random.binomial(n=1, p=0.5, size=(totalbit_OFDM, ))

# mapping = {
#     (0, 0, 0, 0): -3-3j,
#     (0, 0, 0, 1): -3-1j,
#     (0, 0, 1, 0): -3+3j,
#     (0, 0, 1, 1): -3+1j,
#     (0, 1, 0, 0): -1-3j,
#     (0, 1, 0, 1): -1-1j,
#     (0, 1, 1, 0): -1+3j,
#     (0, 1, 1, 1): -1+1j,
#     (1, 0, 0, 0): 3-3j,
#     (1, 0, 0, 1): 3-1j,
#     (1, 0, 1, 0): 3+3j,
#     (1, 0, 1, 1): 3+1j,
#     (1, 1, 0, 0): 1-3j,
#     (1, 1, 0, 1): 1-1j,
#     (1, 1, 1, 0): 1+3j,
#     (1, 1, 1, 1): 1+1j
# }




def qam_mapping(M):
    n = int(np.log2(M))
    mapping = {}
    for i, bits in enumerate(itertools.product([0, 1], repeat=n)):
        I = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[:n // 2])]) - (2 ** (n // 2)) + 1
        Q = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[n // 2:])]) - (2 ** (n // 2)) + 1
        mapping[bits] = I + 1j * Q
    return mapping
mapping = qam_mapping(2**M)
demapping_table = {v: k for k, v in mapping.items()}

def S_P(bits):
    return bits.reshape(len(dataCarriers), M)

bits_SP = S_P(bit_sequence)

def Mapping(bits):
    return np.array([mapping[tuple(b)] for b in bits])

QAM = Mapping(bits_SP)

def OFDM_symbol(QAM_payload):
    symbol = np.zeros(K, dtype=complex)
    symbol[pilotCarriers] = pilotValue
    symbol[dataCarriers] = QAM_payload
    return symbol

OFDM_data = OFDM_symbol(QAM)

def IDFT(OFDM_data):
    return np.fft.ifft(OFDM_data)

OFDM_time = IDFT(OFDM_data)

def addCP(OFDM_time):
    cp = OFDM_time[-CP:]
    return np.hstack([cp, OFDM_time])

OFDM_withCP = addCP(OFDM_time)
print(OFDM_withCP)

def channel(signal, snr_db):
    Y = np.convolve(signal, Channel_response)[:len(signal)]
    signal_power = np.mean(abs(Y**2))
    noise_power = signal_power * 10**(-snr_db / 10)
    noise = np.sqrt(noise_power/2) * (np.random.randn(*Y.shape) + 1j*np.random.randn(*Y.shape))
    return Y + noise

def removeCP(signal):
    return signal[CP:(CP + K)]

def DFT(OFDM_RX):
    return np.fft.fft(OFDM_RX)

def channelEstimate(OFDM_demod):
    pilots = OFDM_demod[pilotCarriers]
    H_est_at_pilots = pilots / pilotValue

    H_est_abs = scipy.interpolate.interp1d(pilotCarriers, abs(H_est_at_pilots), kind='linear')(allCarriers)
    H_est_phase = scipy.interpolate.interp1d(pilotCarriers, np.angle(H_est_at_pilots), kind='linear')(allCarriers)
    H_est = H_est_abs * np.exp(1j * H_est_phase)

    return H_est

def equalize(OFDM_demod, H_est):
    return OFDM_demod / H_est

def get_payload(equalized):
    return equalized[dataCarriers]

def demapping(QAM):
    constel = np.array([x for x in demapping_table.keys()])
    dis = abs(QAM.reshape((-1, 1)) - constel.reshape((1, -1)))
    constel_index = dis.argmin(axis=1)
    HDecision = constel[constel_index]
    return np.vstack([demapping_table[C] for C in HDecision]), HDecision

def PS(bits):
    return bits.reshape((-1,))

BER = []

for snr_db in SNRdB:
    A = np.zeros(10000)
    for i in range(10000):
        OFDM_RX = channel(OFDM_withCP, snr_db)
        OFDM_RX_noCP = removeCP(OFDM_RX)
        OFDM_demod = DFT(OFDM_RX_noCP)
        H_est = channelEstimate(OFDM_demod)
        equalized_H_est = equalize(OFDM_demod, H_est)
        QAM_est = get_payload(equalized_H_est)
        PS_est, HDecision = demapping(QAM_est)
        bits_est = PS(PS_est)
        A[i] = np.mean(bit_sequence != bits_est)
    BER.append(np.mean(A))

for qam, hard in zip(QAM_est, HDecision):
    plt.plot([qam.real, hard.real], [qam.imag, hard.imag], 'b-o')
    plt.plot(HDecision.real, HDecision.imag, 'ro')

plt.figure(figsize=(8, 4))
plt.plot(SNRdB, BER, 'bo-')
plt.semilogy()
plt.xlabel('SNR (dB)')
plt.ylabel('BER')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erf, erfc
import scipy
import itertools

class OFDM:
    def __init__(self, Nsubcarrier, M):
        self.K = Nsubcarrier

        # cyclic prefix
        self.CP = self.K // 4

        # pilot
        self.P = self.K // 8
        self.M = M  # bits per symbol
        self.Channel_response = np.array([1])
        self.H_exact = np.fft.fft(self.Channel_response, self.K)

        self.SNRdB = np.linspace(1, 25, num=25)
        self.pilotValue = 3 + 3j
        self.allCarriers = np.arange(self.K)
        self.pilotCarriers = self.allCarriers[::self.K // self.P]
        self.pilotCarriers = np.hstack([self.pilotCarriers, np.array([self.allCarriers[-1]])])
        self.P = self.P + 1

        # Carrier mang thông tin
        self.dataCarriers = np.delete(self.allCarriers, self.pilotCarriers)
        self.totalbit_OFDM = len(self.dataCarriers) * self.M
        self.bit_sequence = np.random.binomial(n=1, p=0.5, size=(self.totalbit_OFDM, ))

        self.mapping = self.qam_mapping(2**self.M)
        demapping_table = {v: k for k, v in self.mapping.items()}

        self.bits_SP = self.S_P(self.bit_sequence)
        self.QAM = self.Mapping(self.bits_SP)
        self.OFDM_data = self.OFDM_symbol(self.QAM)
        self.OFDM_time = self.IDFT(self.OFDM_data)
        OFDM_withCP = self.addCP(self.OFDM_time)

        self.BER = []

        for snr_db in self.SNRdB:
            self.A = np.zeros(100)
            for i in range(100):
                OFDM_RX = self.channel(OFDM_withCP, snr_db)
                OFDM_RX_noCP = self.removeCP(OFDM_RX)
                OFDM_demod = self.DFT(OFDM_RX_noCP)
                H_est = self.channelEstimate(OFDM_demod)
                equalized_H_est = self.equalize(OFDM_demod, H_est)
                QAM_est = self.get_payload(equalized_H_est)
                PS_est, HDecision = self.demapping(QAM_est, demapping_table)
                bits_est = self.PS(PS_est)
                self.A[i] = np.mean(self.bit_sequence != bits_est)
            self.BER.append(np.mean(self.A))

    def qam_mapping(self, M):
        self.n = int(np.log2(M))
        self.mapping = {}
        for i, bits in enumerate(itertools.product([0, 1], repeat=self.n)):
            self.I = 2 * sum([bit * (2 ** (self.n // 2 - j - 1)) for j, bit in enumerate(bits[:self.n // 2])]) - (2 ** (self.n // 2)) + 1
            self.Q = 2 * sum([bit * (2 ** (self.n // 2 - j - 1)) for j, bit in enumerate(bits[self.n // 2:])]) - (2 ** (self.n // 2)) + 1
            self.mapping[bits] = self.I + 1j * self.Q
        return self.mapping

    def S_P(self, bits):
        return bits.reshape(len(self.dataCarriers), self.M)

    def Mapping(self, bits):
        return np.array([self.mapping[tuple(b)] for b in bits])

    def OFDM_symbol(self, QAM_payload):
        symbol = np.zeros(self.K, dtype=complex)
        symbol[self.pilotCarriers] = self.pilotValue
        symbol[self.dataCarriers] = QAM_payload
        return symbol

    def IDFT(self, OFDM_data):
        return np.fft.ifft(OFDM_data)

    def addCP(self, OFDM_time):
        cp = OFDM_time[-self.CP:]
        return np.hstack([cp, OFDM_time])

    def channel(self, signal, snr_db):
        self.Y = np.convolve(signal, self.Channel_response)[:len(signal)]
        self.signal_power = np.mean(abs(self.Y**2))
        self.noise_power = self.signal_power * 10**(-snr_db / 10)
        self.noise = np.sqrt(self.noise_power/2) * (np.random.randn(*self.Y.shape) + 1j*np.random.randn(*self.Y.shape))
        return self.Y + self.noise

    def removeCP(self, signal):
        return signal[self.CP:(self.CP + self.K)]

    def DFT(self, OFDM_RX):
        return np.fft.fft(OFDM_RX)

    def channelEstimate(self, OFDM_demod):
        pilots = OFDM_demod[self.pilotCarriers]
        H_est_at_pilots = pilots / self.pilotValue

        H_est_abs = scipy.interpolate.interp1d(self.pilotCarriers, abs(H_est_at_pilots), kind='linear')(self.allCarriers)
        H_est_phase = scipy.interpolate.interp1d(self.pilotCarriers, np.angle(H_est_at_pilots), kind='linear')(self.allCarriers)
        H_est = H_est_abs * np.exp(1j * H_est_phase)

        return H_est

    def equalize(self, OFDM_demod, H_est):
        return OFDM_demod / H_est

    def get_payload(self, equalized):
        return equalized[self.dataCarriers]

    def demapping(self, QAM, demapping_table):
        constel = np.array([x for x in demapping_table.keys()])
        dis = abs(QAM.reshape((-1, 1)) - constel.reshape((1, -1)))
        constel_index = dis.argmin(axis=1)
        HDecision = constel[constel_index]
        return np.vstack([demapping_table[C] for C in HDecision]), HDecision

    def PS(self, bits):
        return bits.reshape((-1,))


Cam = OFDM(1024, 6)
Pink = OFDM(1024, 4)
Cam1 = OFDM(1024, 2)
plt.ylim(10**-6,1)
plt.figure(figsize=(8, 4))
plt.plot(Cam.SNRdB, Cam.BER, 'bo-', label='1024 Subcarriers, 64-QAM')
plt.plot(Pink.SNRdB, Pink.BER, 'mo-', label='1024 Subcarriers, 16-QAM')
plt.plot(Cam1.SNRdB, Cam1.BER, 'ro-', label='1024 Subcarriers, 4-QAM')

plt.semilogy()
plt.xlabel('SNR (dB)')
plt.ylabel('BER')
plt.legend()
plt.grid(True)
plt.show()